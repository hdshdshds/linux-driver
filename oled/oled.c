#include <linux/init.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/spi/spi.h>
#include <linux/types.h>
#include <linux/kernel.h>
#include <linux/delay.h>
#include <linux/ide.h>
#include <linux/errno.h>
#include <linux/gpio.h>
#include <asm/mach/map.h>
#include <linux/of.h>
#include <linux/of_address.h>
#include <linux/of_gpio.h>
#include <asm/io.h>
#include <linux/device.h>
#include <linux/platform_device.h>
#include <linux/types.h>
#include <linux/gpio/consumer.h>

#define X_WIDTH 128
#define Y_WIDTH 64

static struct of_device_id spi_oled[] = {
	{.compatible = "stm,spioled"},
	{}
};

struct oled_dev
{
	struct cdev cdev;
	struct class *class;
	struct device *device;
	struct spi_device *spi;
	struct gpio_desc *dc;
	struct gpio_desc *cs;
	struct gpio_desc *reset;
};
static dev_t devno;
u8 ssd1306_init_parameter[] = {
	0xAE, 0xD5, 0x80,0xA8, 0x3F, 0xD3, 0x00, 0x40, 
	0x8D,0x14, 0x20, 0x00, 0xA1, 0xC8, 0xDA, 0x12, 
	0x81, 0x80, 0xD9, 0xF1,0xDB, 0x20, 0xA4, 0xA6,
	0x2E, 0xAF
};
static const uint8_t etx_logo[1024] = {
  0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xE1, 0xF9, 0xFF, 0xF9, 0xE1, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF,
  0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xF8, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF,
  0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
  0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0x0F, 0xF8, 0xF7, 0x00, 0xBF, 0xC0, 0x7F,
  0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
  0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3F, 0xE0, 0x0F, 0x7F, 0x00, 0xFF, 0x7F, 0x80,
  0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x04, 0xFC, 0xFC, 0x0C, 0x0C, 0x0C, 0x0C, 0x7C, 0x00, 0x00, 0x00,
  0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFC, 0xF8,
  0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x08,
  0x04, 0x04, 0xFC, 0xFC, 0x04, 0x04, 0x04, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x98, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80,
  0x00, 0x00, 0x04, 0x0C, 0x38, 0xE0, 0x80, 0xE0, 0x38, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x00, 0xFF,
  0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xC0, 0x3F, 0xFF, 0xFF, 0x00, 0xFD, 0xFE, 0xFF,
  0x01, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x06, 0x06, 0x06, 0x06, 0xE0, 0x00, 0x00, 0x00,
  0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
  0x00, 0x00, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x7C, 0xFF, 0x11, 0x10, 0x1F, 0x1F, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x7C, 0xFF, 0x01, 0x00, 0x01, 0xFF, 0x7C, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
  0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x87,
  0x00, 0x00, 0x00, 0x00, 0xE0, 0x3F, 0x1F, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
  0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1F, 0x3F, 0xFC, 0xF7, 0x00, 0xDF, 0xE3, 0x7D,
  0x3E, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00,
  0x00, 0x03, 0x03, 0x00, 0x03, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03,
  0x02, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x03, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x03,
  0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x02, 0x02, 0x03,
  0x00, 0x00, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0xFF,
  0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0xFF, 0x03, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x88, 0x88, 0x08, 0x00, 0xE0, 0x20, 0x20, 0xE0, 0x20, 0xE0,
  0x00, 0xFC, 0x20, 0x20, 0xE0, 0x00, 0xE0, 0x20, 0x20, 0xE0, 0x00, 0xE0, 0x20, 0x20, 0xFC, 0x00,
  0xE0, 0x20, 0x20, 0xFC, 0x00, 0xE0, 0x20, 0x20, 0xE0, 0x00, 0xE0, 0x20, 0x20, 0xFC, 0x00, 0x00,
  0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0xE0, 0x00, 0xE0, 0x00, 0xFC, 0x20, 0x20, 0x00, 0xE0,
  0x20, 0x20, 0xE0, 0x00, 0xE0, 0x20, 0x20, 0x00, 0xEC, 0x00, 0x20, 0x20, 0x20, 0xE0, 0x00, 0xFC,
  0x00, 0xE0, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0xC8, 0x38, 0x00, 0x00, 0xE0,
  0x20, 0x20, 0xE0, 0x00, 0xE0, 0x20, 0xE0, 0x00, 0xE0, 0x20, 0x20, 0xE0, 0x00, 0x00, 0x00, 0xFF,
  0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x9C, 0x9C, 0x88, 0x8E, 0x83, 0x98, 0x83, 0x8E, 0x88,
  0x88, 0x9C, 0x9C, 0x80, 0x80, 0x87, 0x84, 0x84, 0x84, 0x80, 0x87, 0x80, 0x80, 0x87, 0x80, 0x87,
  0x80, 0x87, 0x84, 0x84, 0x87, 0x80, 0x87, 0x85, 0x85, 0x85, 0x80, 0x87, 0x84, 0x84, 0x87, 0x80,
  0x87, 0x84, 0x84, 0x87, 0x80, 0x87, 0x85, 0x85, 0x85, 0x80, 0x87, 0x84, 0x84, 0x87, 0x80, 0x80,
  0x80, 0x80, 0x80, 0x87, 0x80, 0x80, 0x80, 0x87, 0x84, 0x87, 0x80, 0x87, 0x84, 0x84, 0x80, 0x87,
  0x84, 0x84, 0x87, 0x80, 0x87, 0x80, 0x80, 0x80, 0x87, 0x80, 0x87, 0x85, 0x85, 0x87, 0x80, 0x87,
  0x80, 0x85, 0x85, 0x85, 0x87, 0x80, 0x80, 0x80, 0x80, 0x86, 0x85, 0x84, 0x84, 0x84, 0x80, 0x87,
  0x84, 0x84, 0x87, 0x80, 0x87, 0x80, 0x87, 0x80, 0x87, 0x85, 0x85, 0x85, 0x80, 0x80, 0x80, 0xFF
};
static void spi_write_bytes(struct spi_device *spi, u8  *data, u16 len)
{
	
	int ret = -1;
	struct spi_message m;
	struct spi_transfer *t;
	unsigned char *txdata;
	t = kzalloc(sizeof(struct spi_transfer), GFP_KERNEL);
	if (!t)
		return;
	
	txdata = (unsigned char *)kzalloc(len, GFP_KERNEL);
	if (!txdata)
	{
		kfree(t);
		return;
	}
	memcpy(txdata, data, len);
	t->tx_buf = txdata;
	t->len = len;
	spi_message_init(&m);
	spi_message_add_tail(t, &m);
	ret = spi_sync(spi, &m);

	if(ret)
		printk("Failed to send data, ret = %d", ret);
	
	kfree(t);
	kfree(txdata);
}
/*
 *param@cmd :1 cmd,0 data
*/
static void ssd1306_write(struct oled_dev *dev, u8 *data, u16 len, u8 cmd)
{
	if (cmd == 1)
	{
		gpiod_set_raw_value(dev->dc, 0);
	} else if (cmd == 0)
	{
		gpiod_set_raw_value(dev->dc, 1);
	} else 
	{
		printk("[ oled ] invalid paramter\n");
	}		
	spi_write_bytes(dev->spi, data, len);
}

static void ssd1306_write_one_byte(struct oled_dev *dev, u8 data, u8 cmd)
{
	int len = 1;
	if (cmd==1)
	{
		gpiod_set_value(dev->dc, 0);

		spi_write_bytes(dev->spi, &data, len);
	} else if (cmd == 0)
	{
		gpiod_set_value(dev->dc, 1);
		spi_write_bytes(dev->spi, &data, len);
	} else 
	{
		printk("[ oled ] invalid paramter\n");
	}
}
void ssd1306_set_cursor(struct oled_dev *dev ,u8 line, u8 curpos)
{
	ssd1306_write_one_byte(dev, 0x21, 1);
	ssd1306_write_one_byte(dev, curpos, 1);
    ssd1306_write_one_byte(dev, 128-1, 1);

	ssd1306_write_one_byte(dev, 0x22, 1);
	ssd1306_write_one_byte(dev, line, 1);
    ssd1306_write_one_byte(dev, 7, 1);
}
static void ssd1306_fill(struct oled_dev *dev, u8 data)
{
	int i, len = X_WIDTH * Y_WIDTH/8;
	u8 buffer[30];
	for(i=0; i< 30; i++)
		buffer[i] = data;
	ssd1306_set_cursor(dev, 0, 0);

	for (i=0; i< len/30; i++)
		ssd1306_write(dev, buffer, 30, 0);

	if (len%30)
		ssd1306_write(dev, buffer, len%30, 0);
}
static void ssd1306_init(struct oled_dev *dev)
{
	int i;
	gpiod_set_raw_value(dev->reset, 0);
	msleep(100);
	gpiod_set_raw_value(dev->reset, 1);
	msleep(100);
	ssd1306_write(dev, ssd1306_init_parameter, sizeof(ssd1306_init_parameter), 1);
	ssd1306_write_one_byte(dev, 0x81, 1); //set brigthness
	ssd1306_write_one_byte(dev, 255, 1);
	ssd1306_write_one_byte(dev, 0xA6, 1); //normal display
	ssd1306_fill(dev, 0x00);

	ssd1306_set_cursor(dev, 0, 0);
	for (i=0; i<X_WIDTH * Y_WIDTH/8 ;i ++)
		ssd1306_write_one_byte(dev, etx_logo[i], 0);
}
static int write(struct file *filp, const char __user *buf, size_t cnt, loff_t *off)
{
	//int ret;
	//struct oled_dev *cdev = (struct oled_dev *)filp->private_data;
	return 0;
}

static int read(struct file *filp, char __user *buf, size_t cnt, loff_t *off)
{
	//struct oled_dev *dev = (struct oled_dev*)filp->private_data;
	return 0;
}
static int open(struct inode *inode, struct file *filp)
{
	struct oled_dev *cdev = (struct oled_dev*)container_of(inode->i_cdev, struct oled_dev, cdev);
	filp->private_data = cdev;
	ssd1306_init(cdev);
	return 0;
}


static int close(struct inode *inode, struct file *filp)
{
	return 0;
}

static struct file_operations oled_chrdev_fops = {
	.owner = THIS_MODULE,
	.open = open,
	.release = close,
	.write = write,
	.read = read,
};

static int pdrv_probe(struct spi_device *spi)
{

	int ret; 
	struct oled_dev *oled;
	struct device *dev = &spi->dev;
	dev_t cur_dev;

	
	printk("[ oled ] platform driver probe\n");

	ret = alloc_chrdev_region(&devno, 0, 1, "oled_dev");
	if (ret < 0)
	{
		printk("[ oled ] Failed to alloc chardev  \n");
		return -ENOMEM;
	}
	cur_dev = MKDEV(MAJOR(devno), MINOR(devno));
	oled = devm_kzalloc(&spi->dev, sizeof(struct oled_dev), GFP_KERNEL);
	if (!oled)
		return -ENOMEM;
	

	oled->spi = spi;
	oled->spi->max_speed_hz = 5000000;
	spi->mode = SPI_MODE_0;
	spi_setup(spi);
	spi_set_drvdata(spi, oled);



	cdev_init(&oled->cdev, &oled_chrdev_fops);
	
	ret = cdev_add(&oled->cdev, cur_dev, 1);
	if (ret < 0)
	{
		printk("[ oled ] Failed to add cdev\n");
		goto del_unregister;
	}

	oled->class =  class_create(THIS_MODULE, "oled_class");
	if ( !oled->class)
	{
		printk("[ oled ] Failed to create class\n");
		goto del_cdev;
	}

	oled->device = device_create(oled->class, NULL, cur_dev, NULL, "oled_dev");
	if ( !oled->device)
	{
		printk("[ oled ] Failed to create class\n");
		goto del_class;
	}

	/* spi init */
	oled->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
	if (IS_ERR(oled->dc))
	{
		printk("[ oled ] Failed to get reset\n");
		goto del_class;
	}
	oled->dc = devm_gpiod_get(dev, "dc", GPIOD_OUT_HIGH);
	if (IS_ERR(oled->dc))
	{
		printk("[ oled ] Failed to get dc\n");
		goto del_class;
	}
	//oled->cs = devm_gpiod_get(dev, "cs", GPIOD_OUT_HIGH);

	printk("dc %02X reset %02X\n", desc_to_gpio(oled->dc),desc_to_gpio(oled->reset) );
	//gpiod_direction_output(oled->dc, 1);
    //gpiod_direction_output(oled->reset, 1);

	printk("max_speed_hz = %d\n", oled->spi->max_speed_hz);
	printk("chip_select = %d\n", (int) oled->spi->chip_select);
	printk("bits_per_word = %d\n", (int) oled->spi->bits_per_word);
	printk("mode = %02X\n",  oled->spi->mode);
	printk("cs_gpio = %02X\n",  oled->spi->cs_gpio);

	
	
	return 0;

del_class:
	class_destroy(oled->class);
del_cdev:
	cdev_del(&oled->cdev);
del_unregister:
	unregister_chrdev_region(cur_dev, 1);

	return ret;
}

static int pdrv_remove( struct spi_device *spi)
{
	dev_t cur_dev;
	
	struct oled_dev *oled = spi_get_drvdata(spi);
	cur_dev = MKDEV(MAJOR(devno), MINOR(devno));
	device_destroy(oled->class, cur_dev);
	class_destroy(oled->class);
	cdev_del(&oled->cdev);
	unregister_chrdev_region(cur_dev, 1);
	return 0;
}

static struct spi_driver oled_driver = {
	.probe = pdrv_probe,
	.remove = pdrv_remove,
	.driver = {
		.name = "spi_oled",
		.owner = THIS_MODULE,
		.of_match_table = spi_oled,
	}
};

module_spi_driver(oled_driver);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("hds");
MODULE_DESCRIPTION("oled module");
MODULE_ALIAS("oled driver");

